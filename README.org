#+TITLE: PL/.NET

* Installation

PL/.NET is installed like any regular PostgreSQL extension. First, obtain it by
cloning the repository, after that just run:

#+BEGIN_SRC shell
$ make && make plnet-install
$ psql -c "CREATE EXTENSION pldotnet;" <mydb>
#+END_SRC

The PL/.NET extension installs both C# (~plcsharp~) and F# (~plfsharp~) modules
for using them as loadable procedure languages.

* Types

PL/.NET uses three different approaches for type conversion of function's
arguments between PostgreSQL and .NET runtime environment, here's a list of them:

1. Convert to string/text (~decimal~);
2. Natively convert using ~System.Runtime.InteropServices~;
3. For null support, convert the type to its respective ~Nullable<>~ type (~bool~, ~integers~).

The following table shows each type conversion equivalences:

| PostgreSQL type     | C# type                            | F# type               |
|---------------------+------------------------------------+-----------------------|
| bool                | Nullable<System.Boolean> (~bool?~) | < Not yet supported > |
| int2                | Nullable<System.Int16> (~short?~)  | < Not yet supported > |
| int4                | Nullable<System.Int32> (~int?~)    | System.Int32 (~int~)  |
| int8                | Nullable<System.Int64> (~long?~)   | < Not yet supported > |
| float4              | System.Single (~float~)            | < Not yet supported > |
| float8              | System.Double (~double~)           | < Not yet supported > |
| char, varchar, text | System.String (~string~)           | < Not yet supported > |
| "char"/bpchar       | System.String (~string~)           | < Not yet supported > |
| numeric             | System.Decimal (~decimal~)         | < Not yet supported > |
| Arrays              | < Not yet supported >              | < Not yet supported > |
| Composite           | < Not yet supported >              | < Not yet supported > |
| Base, domain        | < Not yet supported >              | < Not yet supported > |

* Functions
  Functions for PG/.NET languages are created as:

#+BEGIN_SRC sql
CREATE FUNCTION func(args) RETURN return_type AS $$
    -- < C# / F# function body >
$$ LANGUAGE [ plcsharp | plfsharp];
#+END_SRC

where the types of the named arguments(~args~) and ~return_type~ are converted
following the table in Types section.

The function body are composed to its respectively language chunk following the
templates below:

+ C#

#+BEGIN_SRC csharp
libargs.resu = FUNC(args);
return_type FUNC(args) {
   // C# function body
}
#+END_SRC

+ F#

#+BEGIN_SRC fsharp
type Lib =
    static member FUNC =
        // F# function body
    static member Main =
        libargs.resu <- FUNC args
#+END_SRC

PL/.NET hosts the .NET runtime using ~hostfxr~ for loading the delegates, that's why
the procedure function body are inserted into a class structure for both C# and F#.

** Examples
   + C#

#+BEGIN_SRC sql
# CREATE OR REPLACE FUNCTION retVarCharText(fname varchar, lname varchar) RETURNS text AS $$
return "Hello " + fname + lname + "!";
$$ LANGUAGE plcsharp;
CREATE FUNCTION
# SELECT retVarCharText('Homer Jay ', 'Simpson');
      retvarchartext
--------------------------
 Hello Homer Jay Simpson!
(1 row)

#+END_SRC

   + F#

#+BEGIN_SRC sql
# CREATE OR REPLACE FUNCTION returnInt() RETURNS integer AS $$
10
$$ LANGUAGE plfsharp;
CREATE FUNCTION
# SELECT returnInt() = integer '10';
 returnint
-----------
        10
(1 row)

#+END_SRC
